// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"fmt"
	"io"
	"slices"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/microsoft/go-crypto-darwin/internal/mkcgo"
)

// generateGo output Go source file from src.
func generateGo(src *mkcgo.Source, w io.Writer) {
	// Output header notice and package declaration.
	fmt.Fprintf(w, "// Code generated by mkcgo. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "package %s\n\n", *packageName)

	// This block outputs C header includes and forward declarations for loader functions.
	fmt.Fprintf(w, "/*\n")
	fmt.Fprintf(w, "#cgo CFLAGS: -Wno-attributes\n")
	if !*useDynamicLoading {
		fmt.Fprintf(w, "#cgo unix LDFLAGS: -ldl\n\n")
	}
	if *includeHeader != "" {
		fmt.Fprintf(w, "#include \"%s\"\n", *includeHeader)
	}
	fmt.Fprintf(w, "#include \"%s\"\n", autogeneratedFileName(".h"))
	fmt.Fprintf(w, "*/\n")
	fmt.Fprintf(w, "import \"C\"\n")
	fmt.Fprintf(w, "import \"unsafe\"\n\n")

	// Generate Externs for C extern variables.
	generateGoExterns(src.Externs, w)

	// Generate Go enum values for C enums.
	generateGoEnums(src.Enums, w)

	// Generate type aliases for all
	generateGoAliases(src.Funcs, src.Externs, src.Enums, w)

	if !*useDynamicLoading {
		// Generate Go wrapper functions that load and unload the C symbols.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "func %s_%s(handle unsafe.Pointer) {\n", goSymName("mkcgoLoad"), tag)
			fmt.Fprintf(w, "\tC.__mkcgo_load_%s(handle)\n", tag)
			fmt.Fprintf(w, "}\n\n")
			fmt.Fprintf(w, "func %s_%s() {\n", goSymName("mkcgoUnload"), tag)
			fmt.Fprintf(w, "\tC.__mkcgo_unload_%s()\n", tag)
			fmt.Fprintf(w, "}\n\n")
		}
	}

	// Generate error wrapper noescape function, which hides the
	// error state pointer from the Go garbage collector.
	// An instance of https://github.com/golang/go/blob/d704ef76068eb7da15520b08dc7df98f45f85ffa/src/runtime/stubs.go#L194-L201
	fmt.Fprintf(w, "//go:nosplit\n")
	fmt.Fprintf(w, "func %s(p *C.%s) *C.%s {\n", mkcgoNoEscape, mkcgoErrState, mkcgoErrState)
	fmt.Fprintf(w, "\tx := uintptr(unsafe.Pointer(p))\n")
	fmt.Fprintf(w, "\treturn (*C.%s)(unsafe.Pointer(x ^ 0))\n", mkcgoErrState)
	fmt.Fprintf(w, "}\n\n")

	// Generate function wrappers.
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}
		if fn.Optional {
			// Generate a function that returns true if the function is available.
			fmt.Fprintf(w, "func %s() bool {\n", fnGoNameAvailable(fn))
			fmt.Fprintf(w, "\treturn C.%s() != 0\n", fnCNameAvailable(fn))
			fmt.Fprintf(w, "}\n\n")
		}
		generateGoFn(fn, w)
	}
}

// generateGo124 generates Go source code Go 1.24 and later.
func generateGo124(src *mkcgo.Source, w io.Writer) {
	// Output header notice and package declaration.
	fmt.Fprintf(w, "// Code generated by mkcgo. DO NOT EDIT.\n\n")
	fmt.Fprintf(w, "//go:build go1.24 && !cmd_go_bootstrap\n\n")
	fmt.Fprintf(w, "package %s\n\n", *packageName)

	// This block outputs C header includes and forward declarations for loader functions.
	fmt.Fprintf(w, "/*\n")
	for _, fn := range src.Funcs {
		name := fnCName(fn)
		if fn.NoEscape {
			fmt.Fprintf(w, "#cgo noescape %s\n", name)
		}
		if fn.NoCallback {
			fmt.Fprintf(w, "#cgo nocallback %s\n", name)
		}
	}
	fmt.Fprintf(w, "*/\n")
	fmt.Fprintf(w, "import \"C\"\n")
}

// generateGoExterns generates Go variables for C extern variables.
func generateGoExterns(externs []*mkcgo.Extern, w io.Writer) {
	if len(externs) == 0 {
		return
	}
	fmt.Fprintf(w, "var (\n")
	for _, extern := range externs {
		fmt.Fprintf(w, "\t%s = C.%s\n", goSymName(extern.Name), extern.Name)
	}
	fmt.Fprintf(w, ")\n\n")
}

// generateGoEnums generates Go enum values for C enums.
func generateGoEnums(enums []*mkcgo.Enum, w io.Writer) {
	for _, enum := range enums {
		fmt.Fprintf(w, "const (\n")
		for _, enumValue := range enum.Values {
			fmt.Fprintf(w, "\t%s %s = %s\n", goSymName(enumValue.Name), enum.Type, enumValue.Value)
		}
		fmt.Fprintf(w, ")\n\n")
	}
}

// generateGoAliases generates Go type aliases for C types.
func generateGoAliases(funcs []*mkcgo.Func, externs []*mkcgo.Extern, enums []*mkcgo.Enum, w io.Writer) {
	// Traverse all functions and collect the unique C types.
	ctypes := make(map[string]struct{})
	handleType := func(typ string) {
		if typ == "" {
			return
		}
		typ = strings.TrimPrefix(typ, "const ")
		typ = strings.TrimRight(typ, "*")
		if _, ok := ctypes[typ]; ok {
			return
		}
		ctypes[typ] = struct{}{}
	}
	for _, fn := range funcs {
		for _, p := range fn.Params {
			if p.Variadic() {
				continue
			}
			handleType(p.Type)
		}
		handleType(fn.Ret)
	}
	for _, extern := range externs {
		handleType(extern.Type)
	}
	for _, enum := range enums {
		handleType(enum.Type)
	}
	types := make([]string, 0, len(ctypes))
	for typ := range ctypes {
		types = append(types, typ)
	}
	slices.Sort(types)
	for _, typ := range types {
		if isStdType(typ) {
			// Skip standard types.
			continue
		}
		fmt.Fprintf(w, "type %s = C.%s\n", goSymName(typ), typ)
	}
}

// generateCHeader generates C header file content with
// the C functions defined in the autogenerated C source file.
func generateCHeader(src *mkcgo.Source, w io.Writer) {
	// Header and includes.
	fmt.Fprintf(w, "// Code generated by mkcgo. DO NOT EDIT.\n\n")

	fmt.Fprintf(w, "#ifndef MKCGO_H // only include this header once\n")
	fmt.Fprintf(w, "#define MKCGO_H\n\n")

	if *includeHeader != "" {
		fmt.Fprintf(w, "#include %q\n\n", *includeHeader)
	}

	// Source includes.
	for _, v := range src.Includes {
		fmt.Fprintf(w, "#include %s\n", v)
	}
	fmt.Fprintf(w, "\n")

	// Source types and enums.
	for _, def := range src.TypeDefs {
		fmt.Fprintf(w, "typedef %s %s;\n", def.Type, def.Name)
	}
	fmt.Fprintf(w, "\n")
	if len(src.Externs) > 0 {
		for _, def := range src.Externs {
			fmt.Fprintf(w, "extern %s %s;\n", def.Type, def.Name)
		}
		fmt.Fprintf(w, "\n")
	}
	for _, enum := range src.Enums {
		if enum.Type != "" {
			fmt.Fprintf(w, "typedef ")
		}
		fmt.Fprintf(w, "enum {\n")
		for _, enumValue := range enum.Values {
			fmt.Fprintf(w, "\t%s = %s,\n", enumValue.Name, enumValue.Value)
		}
		if enum.Type != "" {
			fmt.Fprintf(w, "} %s;", enum.Type)
		} else {
			fmt.Fprintf(w, "};")
		}
		fmt.Fprintf(w, "\n\n")
	}

	// Custom types
	fmt.Fprintf(w, "typedef void* %s;\n", mkcgoErrState)
	fmt.Fprintf(w, "%s mkcgo_err_retrieve();\n", mkcgoErrState)
	fmt.Fprintf(w, "void mkcgo_err_free(%s);\n", mkcgoErrState)
	fmt.Fprintf(w, "void mkcgo_err_clear();\n\n")

	if !*useDynamicLoading {
		// Add forward declarations for loader functions.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "void __mkcgo_load_%s(void* handle);\n", tag)
			fmt.Fprintf(w, "void __mkcgo_unload_%s();\n", tag)
		}
		fmt.Fprintf(w, "\n")
	}

	// Add forward declarations for optional functions.
	for _, fn := range src.Funcs {
		if fn.Optional {
			fmt.Fprintf(w, "int %s();\n", fnCNameAvailable(fn))
		}
	}
	fmt.Fprintf(w, "\n")

	// Add forward declarations for function wrappers returning errors.
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			// cgo doesn't support variadic functions, no need to include them.
			continue
		}
		if fnNeedErrWrapper(fn) {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fnCName(fn), fnCErrWrapperParams(fn, false))
		} else {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fnCName(fn), fnToCArgs(fn, true, false))
		}
	}
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "#endif // MKCGO_H\n")
}

// generateC creates the C source file content.
func generateC(src *mkcgo.Source, w io.Writer) {
	// Header and includes.
	fmt.Fprintf(w, "// Code generated by mkcgo. DO NOT EDIT.\n\n")

	fmt.Fprintf(w, "#include <stddef.h>\n")
	fmt.Fprintf(w, "#include <stdlib.h>\n")
	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintf(w, "#include <stdio.h>\n")
	if *includeHeader != "" {
		fmt.Fprintf(w, "#include %q\n", *includeHeader)
	}
	fmt.Fprintf(w, "#include \"%s\"\n", autogeneratedFileName(".h"))
	fmt.Fprintf(w, "\n")

	if !*useDynamicLoading {
		// Platform-specific includes.
		fmt.Fprintf(w, "#ifdef _WIN32\n")
		fmt.Fprintf(w, "#include <windows.h>\n")
		fmt.Fprintf(w, "#define dlsym GetProcAddress\n")
		fmt.Fprintf(w, "#else\n")
		fmt.Fprintf(w, "#include <dlfcn.h>\n")
		fmt.Fprintf(w, "#endif\n\n")
	}

	// Function pointer declarations.
	for _, fn := range src.Funcs {
		if fn.VariadicTarget != "" {
			continue
		}
		if !*useDynamicLoading {
			fmt.Fprintf(w, "%s (*_g_%s)(%s);\n", fn.Ret, fn.ImportName(), fnToCArgs(fn, true, false))
		} else {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fn.ImportName(), fnToCArgs(fn, true, false))
		}
	}
	fmt.Fprintf(w, "\n")
	if !*useDynamicLoading {
		fmt.Fprintf(w, "#define __mkcgo__dlsym_nocheck(varname, funcname) _g_##varname = (typeof(_g_##varname))dlsym(handle, #funcname);\n\n")
		fmt.Fprintf(w, "#define __mkcgo__dlsym(name) __mkcgo__dlsym2(name, name)\n\n")
		fmt.Fprintf(w, "#define __mkcgo__dlsym2(varname, funcname) \\\n")
		fmt.Fprintf(w, "\t__mkcgo__dlsym_nocheck(varname, funcname) \\\n")
		fmt.Fprintf(w, "\tif (_g_##varname == NULL) { \\\n")
		fmt.Fprintf(w, "\t\tfprintf(stderr, \"Cannot get required symbol \" #funcname \"\\n\"); \\\n")
		fmt.Fprintf(w, "\t\tabort(); \\\n")
		fmt.Fprintf(w, "\t}\n\n")

		// Loader and unloader functions for each tag.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "void __mkcgo_load_%s(void* handle) {\n", tag)
			for _, fn := range src.Funcs {
				if fn.VariadicTarget != "" {
					continue
				}
				tags := fn.Tags
				if len(tags) == 0 {
					tags = []mkcgo.TagAttr{{}}
				}
				for _, tagAttr := range tags {
					if tagAttr.Tag == tag {
						if tagAttr.Name != "" {
							// TODO: if necessary, support optional functions in here too.
							fmt.Fprintf(w, "\t__mkcgo__dlsym2(%s, %s)\n", fn.ImportName(), tagAttr.Name)
						} else if fn.Optional {
							fmt.Fprintf(w, "\t__mkcgo__dlsym_nocheck(%s, %s)\n", fn.ImportName(), fn.ImportName())
						} else {
							fmt.Fprintf(w, "\t__mkcgo__dlsym(%s)\n", fn.ImportName())
						}
						break
					}
				}
			}
			fmt.Fprintf(w, "}\n\n")

			fmt.Fprintf(w, "void __mkcgo_unload_%s() {\n", tag)
			for _, fn := range src.Funcs {
				if fn.VariadicTarget != "" {
					continue
				}
				tags := fn.Tags
				if len(tags) == 0 {
					tags = []mkcgo.TagAttr{{}}
				}
				for _, tagAttr := range tags {
					if tagAttr.Tag == tag {
						fmt.Fprintf(w, "\t_g_%s = NULL;\n", fn.ImportName())
						break
					}
				}
			}
			fmt.Fprintf(w, "}\n\n")
		}
	}

	// Generate C function wrappers.
	typedefs := make(map[string]string, len(src.TypeDefs))
	for _, def := range src.TypeDefs {
		typedefs[def.Name] = def.Type
	}
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			// cgo doesn't support variadic functions, no need to include them.
			continue
		}
		if fn.Optional {
			// Generate a function that returns true if the function is available.
			fmt.Fprintf(w, "int %s() {\n", fnCNameAvailable(fn))
			fmt.Fprintf(w, "\treturn _g_%s != NULL;\n", fn.ImportName())
			fmt.Fprintf(w, "}\n\n")
		}
		generateCFn(typedefs, fn, w)
	}
}

// generateGoFn generates Go function f.
func generateGoFn(fn *mkcgo.Func, w io.Writer) {
	fnCall := fmt.Sprintf("C.%s(%s)", fnCName(fn), fnToGoArgs(fn))
	// Function definition
	fmt.Fprintf(w, "func %s(%s)", goSymName(fn.Name), fnToGoParams(fn))
	if isVoid(fn.Ret) {
		// Easy path, just call the C function. No need to write the return types,
		// nor do error handling, nor cast the return value.
		fmt.Fprintf(w, "{\n")
		fmt.Fprintf(w, "\t%s\n", fnCall)
		fmt.Fprintf(w, "}\n\n")
		return
	}
	goType, needCast := cTypeToGo(fn.Ret, false)
	if fn.NoError || !*errors {
		fmt.Fprintf(w, " %s ", goType)
	} else {
		fmt.Fprintf(w, " (%s, error) ", goType)
	}
	fmt.Fprintf(w, "{\n")

	// Function call
	var needUnsafeCast bool
	if needCast && goType[0] == '*' {
		goType = fmt.Sprintf("(%s)(unsafe.Pointer", goType)
		needUnsafeCast = true
	}
	if fn.NoError || !*errors {
		// No error handling, just cast the return value if necessary.
		fmt.Fprintf(w, "\treturn ")
		if needCast {
			fmt.Fprintf(w, "%s(%s)", goType, fnCall)
			if needUnsafeCast {
				fmt.Fprintf(w, ")")
			}
		} else {
			fmt.Fprintf(w, "%s", fnCall)
		}
		fmt.Fprintf(w, "\n")
		fmt.Fprintf(w, "}\n\n")
		return
	}
	fmt.Fprintf(w, "\tvar _err C.%s\n", mkcgoErrState)
	fmt.Fprintf(w, "\t_ret := C.%s(", fnCName(fn))
	args := fnToGoArgs(fn)
	if len(args) > 0 {
		args += ", "
	}
	fmt.Fprintf(w, "%s%s(&_err))\n", args, mkcgoNoEscape)

	// Return the value
	fmt.Fprintf(w, "\treturn ")
	if needCast {
		fmt.Fprintf(w, "%s(_ret)", goType)
		if needUnsafeCast {
			fmt.Fprintf(w, ")")
		}
	} else {
		fmt.Fprintf(w, "_ret")
	}
	fmt.Fprintf(w, ", newMkcgoErr(%q, _err)\n", fn.Name)
	fmt.Fprintf(w, "}\n\n")
}

func generateCFn(typedefs map[string]string, fn *mkcgo.Func, w io.Writer) {
	var prefix string
	if !*useDynamicLoading {
		prefix = "_g_"
	}
	if !fnNeedErrWrapper(fn) {
		fmt.Fprintf(w, "%s %s(%s) {\n\t", fn.Ret, fnCName(fn), fnToCArgs(fn, true, true))
		if !isVoid(fn.Ret) {
			fmt.Fprintf(w, "return ")
		}
		fmt.Fprintf(w, "%s%s(%s);\n", prefix, fn.ImportName(), fnToCArgs(fn, false, true))
		fmt.Fprintf(w, "}\n\n")
		return
	}

	fmt.Fprintf(w, "%s %s(%s) {\n", fn.Ret, fnCName(fn), fnCErrWrapperParams(fn, true))
	fmt.Fprintf(w, "\tmkcgo_err_clear();\n") // clear any previous error
	fmt.Fprintf(w, "\t%s _ret = %s%s(%s);\n", fn.Ret, prefix, fn.ImportName(), fnToCArgs(fn, false, true))
	errCond := "<= 0"
	if fn.ErrCond != "" {
		errCond = fn.ErrCond
	} else if strings.Contains(fn.Ret, "*") {
		errCond = "== NULL"
	} else if typ, ok := typedefs[fn.Ret]; ok && typ == "void*" {
		errCond = "== NULL"
	}
	fmt.Fprintf(w, "\tif (_ret %s) *_err_state = mkcgo_err_retrieve();\n", errCond)
	fmt.Fprintf(w, "\treturn _ret;\n")
	fmt.Fprintf(w, "}\n\n")
}

// paramToGo converts C parameter p to Go parameter.
func paramToGo(p *mkcgo.Param, hidden bool) string {
	goType, needCast := cTypeToGo(p.Type, true)
	if !needCast {
		if hidden && goType == "unsafe.Pointer" {
			// The parameter is not annotated with cgoCheckPointer by cgo
			// if it has the form unsafe.Pointer(&...).
			// See https://go-review.googlesource.com/c/go/+/404295.
			// TODO: support other types.
			return fmt.Sprintf("unsafe.Pointer(&*(*byte)(%s))", p.Name)
		}
		return p.Name
	}
	switch {
	case goType == "":
		return p.Name
	case goType[0] == '*':
		return fmt.Sprintf("(%s)(unsafe.Pointer(%s))", goType, p.Name)
	}
	return fmt.Sprintf("%s(%s)", goType, p.Name)
}

// isStdType reports whether t is a standard C type.
func isStdType(t string) bool {
	_, found := cstdTypesToGo[t]
	return found
}

// cstdTypesToGo maps C standard types to Go types.
var cstdTypesToGo = map[string]string{
	"int8_t":             "int8",
	"uint8_t":            "uint8",
	"int16_t":            "int16",
	"uint16_t":           "uint16",
	"int32_t":            "int32",
	"uint32_t":           "uint32",
	"int64_t":            "int64",
	"uint64_t":           "uint64",
	"int":                "int32",
	"unsigned int":       "uint32",
	"long":               "int32",
	"unsigned long":      "uint32",
	"long long":          "int64",
	"unsigned long long": "uint64",
	"size_t":             "int",
	"uintptr_t":          "uintptr",
	"char":               "byte",
	"unsigned char":      "byte",
	"signed char":        "int8",
	"void":               "",
}

// cstdTypesToCgo maps C standard types to special cgo types.
// Most C don't need any special handling, only the ones that have spaces.
var cstdTypesToCgo = map[string]string{
	"signed char":        "schar",
	"unsigned char":      "uchar",
	"unsigned short":     "ushort",
	"unsigned int":       "uint",
	"unsigned long":      "ulong",
	"long long":          "longlong",
	"unsigned long long": "ulonglong",
}

// cTypeToGo converts C type t to a Go type.
// If cgo is true, it returns the type that can be
// passed to a cgo function call.
// It returns the Go type and a boolean that reports whether
// the type needs to be casted to goType or not.
func cTypeToGo(t string, cgo bool) (string, bool) {
	t, _ = strings.CutPrefix(t, "const ")
	if isVoid(t) {
		return "", true
	}
	if strings.HasPrefix(t, "void*") {
		n := strings.Count(t, "*")
		return strings.Repeat("*", n-1) + "unsafe.Pointer", false
	}
	if strings.HasSuffix(t, "*") {
		// Remove all trailing '*' characters.
		var i, n int
		for i = len(t) - 1; i >= 0; i-- {
			if t[i] != '*' {
				break
			}
			n++
		}
		s, std := cTypeToGo(t[:i+1], cgo)
		if s != "" {
			s = strings.Repeat("*", n) + s
		}
		return s, std
	}
	if !isStdType(t) {
		return goSymName(t), false
	}
	if cgo {
		if s, ok := cstdTypesToCgo[t]; ok {
			t = s
		}
		return "C." + t, true
	}
	if t, ok := cstdTypesToGo[t]; ok {
		return t, true
	}
	return t, true
}

// paramToC returns C source code of parameter p.
func paramToC(i int, p *mkcgo.Param, addType, addName bool) string {
	if p.Type == "..." {
		return "..."
	}
	var s string
	if addType {
		s += p.Type
	}
	if addName && !isVoid(p.Type) {
		if len(s) > 0 {
			s += " "
		}
		s += "_arg" + strconv.Itoa(i)
	}
	return s
}

// isVoid reports whether typ is a void type.
func isVoid(typ string) bool {
	return typ == "void"
}

// fnToGoParams returns source code for function f parameters.
func fnToGoParams(fn *mkcgo.Func) string {
	return join(fn.Params, func(_ int, p *mkcgo.Param) string {
		typ, _ := cTypeToGo(p.Type, false)
		return p.Name + " " + typ
	}, ", ")
}

// argList returns source code for C parameters for function f.
func fnToGoArgs(fn *mkcgo.Func) string {
	return join(fn.Params, func(_ int, p *mkcgo.Param) string {
		return paramToGo(p, slices.Contains(fn.NoCheckPtrParams, p.Name))
	}, ", ")
}

// fnToCArgs returns source code for C parameters for function f.
func fnToCArgs(fn *mkcgo.Func, addType, addName bool) string {
	return join(fn.Params, func(i int, p *mkcgo.Param) string {
		return paramToC(i, p, addType, addName)
	}, ", ")
}

// join concatenates parameters ps into a string with sep separator.
// Each parameter is converted into string by applying fn to it
// before conversion.
func join(ps []*mkcgo.Param, fn func(int, *mkcgo.Param) string, sep string) string {
	if len(ps) == 0 {
		return ""
	}
	params := make([]string, 0, len(ps))
	for i, p := range ps {
		param := fn(i, p)
		if param != "" {
			params = append(params, param)
		}
	}
	return strings.Join(params, sep)
}

const mkcgoNoEscape = "mkcgoNoEscape"
const mkcgoErrState = "mkcgo_err_state"

// fnCErrWrapperParams returns source code for C parameters for function f
// with the error state added as the last parameter.
func fnCErrWrapperParams(fn *mkcgo.Func, addName bool) string {
	errArg := mkcgoErrState + " *"
	if addName {
		errArg += "_err_state"
	}
	args := fnToCArgs(fn, true, addName)
	if len(args) == 0 {
		args = errArg
	} else if isVoid(args) {
		args = errArg
	} else {
		args += ", " + errArg
	}
	return args
}

func fnGoNameAvailable(fn *mkcgo.Func) string {
	return goSymName(fn.Name) + "_Available"
}

// fnCName returns the C function name for function f.
func fnCName(fn *mkcgo.Func) string {
	return "_mkcgo_" + fn.Name
}

// fnCNameAvailable returns the C function name for function f
// that checks if the function is available.
func fnCNameAvailable(fn *mkcgo.Func) string {
	return "_mkcgo_available_" + fn.Name
}

// fnNeedErrWrapper reports whether function fn needs an error wrapper.
func fnNeedErrWrapper(fn *mkcgo.Func) bool {
	return *errors && !fn.NoError && !isVoid(fn.Ret)
}

// fnCalledFromGo reports whether function fn is called from Go code.
func fnCalledFromGo(fn *mkcgo.Func) bool {
	return !fn.Variadic() // cgo doesn't support variadic functions
}

// goSymName returns the Go symbol name for a C symbol name.
// The returned name can be transformed depending on the
// value of the private flag.
func goSymName(name string) string {
	if name == "" {
		panic("empty name")
	}
	ch, _ := utf8.DecodeRuneInString(name)
	isPrivate := !unicode.IsUpper(ch)
	if *private == isPrivate {
		// Same access level, no need to change.
		return name
	}
	if !isPrivate {
		// Exported name, make it private by adding an underscore.
		return "_" + name
	}
	// Unexported name, make it exported.
	if name[0] == '_' {
		// If it starts with an underscore, remove it
		// and try again.
		name = strings.TrimPrefix(name, "_")
		return goSymName(name)
	}
	// Uppercase the first letter.
	return strings.ToUpper(name[:1]) + name[1:]
}
