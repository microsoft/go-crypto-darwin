// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"fmt"
	"io"
	"slices"
	"strconv"
	"strings"
	"unicode"
	"unicode/utf8"

	"github.com/microsoft/go-crypto-darwin/internal/mkcgo"
)

func printHeader(w io.Writer) {
	fmt.Fprintf(w, "// Copyright (c) Microsoft Corporation.\n")
	fmt.Fprintf(w, "// Licensed under the MIT License.\n")
	fmt.Fprintf(w, "// Code generated by mkcgo. DO NOT EDIT.\n\n")
}

// generateGo output Go source file from src.
func generateGo(src *mkcgo.Source, w io.Writer) {
	// Output header notice and package declaration.
	printHeader(w)
	fmt.Fprintf(w, "package %s\n\n", *packageName)

	// This block outputs C header includes and forward declarations for loader functions.
	fmt.Fprintf(w, "/*\n")
	fmt.Fprintf(w, "#cgo CFLAGS: -Wno-attributes\n")
	if !*useDynamicLoading {
		fmt.Fprintf(w, "#cgo unix LDFLAGS: -ldl\n\n")
	}
	if *includeHeader != "" {
		fmt.Fprintf(w, "#include \"%s\"\n", *includeHeader)
	}
	fmt.Fprintf(w, "#include \"%s\"\n", autogeneratedFileName(".h"))
	fmt.Fprintf(w, "*/\n")
	fmt.Fprintf(w, "import \"C\"\n")
	fmt.Fprintf(w, "import \"unsafe\"\n\n")

	// Generate Externs for C extern variables.
	generateGoExterns(src.Externs, w)

	// Generate Go enum values for C enums.
	generateGoEnums(src.Enums, w)

	// Generate type aliases for all
	generateGoAliases(src.Funcs, src.Externs, src.Enums, w)

	if !*useDynamicLoading {
		// Generate Go wrapper functions that load and unload the C symbols.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "func %s_%s(handle unsafe.Pointer) {\n", goSymName("mkcgoLoad"), tag)
			fmt.Fprintf(w, "\tC.__mkcgo_load_%s(handle)\n", tag)
			fmt.Fprintf(w, "}\n\n")
			fmt.Fprintf(w, "func %s_%s() {\n", goSymName("mkcgoUnload"), tag)
			fmt.Fprintf(w, "\tC.__mkcgo_unload_%s()\n", tag)
			fmt.Fprintf(w, "}\n\n")
		}
	}

	// Generate error wrapper noescape function, which hides the
	// error state pointer from the Go garbage collector.
	// An instance of https://github.com/golang/go/blob/d704ef76068eb7da15520b08dc7df98f45f85ffa/src/runtime/stubs.go#L194-L201
	fmt.Fprintf(w, "//go:nosplit\n")
	fmt.Fprintf(w, "func %s(p *C.%s) *C.%s {\n", mkcgoNoEscape, mkcgoErrState, mkcgoErrState)
	fmt.Fprintf(w, "\tx := uintptr(unsafe.Pointer(p))\n")
	fmt.Fprintf(w, "\treturn (*C.%s)(unsafe.Pointer(x ^ 0))\n", mkcgoErrState)
	fmt.Fprintf(w, "}\n\n")

	// Generate function wrappers.
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}
		if fn.Optional {
			// Generate a function that returns true if the function is available.
			fmt.Fprintf(w, "func %s() bool {\n", fnGoNameAvailable(fn))
			fmt.Fprintf(w, "\treturn C.%s() != 0\n", fnCNameAvailable(fn))
			fmt.Fprintf(w, "}\n\n")
		}
		generateGoFn(fn, w)
	}
}

// generateGo124 generates Go source code Go 1.24 and later.
func generateGo124(src *mkcgo.Source, w io.Writer) {
	// Output header notice and package declaration.
	printHeader(w)
	fmt.Fprintf(w, "//go:build go1.24 && !cmd_go_bootstrap\n\n")
	fmt.Fprintf(w, "package %s\n\n", *packageName)

	// This block outputs C header includes and forward declarations for loader functions.
	fmt.Fprintf(w, "/*\n")
	for _, fn := range src.Funcs {
		name := fnCName(fn)
		if fn.NoEscape {
			fmt.Fprintf(w, "#cgo noescape %s\n", name)
		}
		if fn.NoCallback {
			fmt.Fprintf(w, "#cgo nocallback %s\n", name)
		}
	}
	fmt.Fprintf(w, "*/\n")
	fmt.Fprintf(w, "import \"C\"\n")
}

// generateGoExterns generates Go variables for C extern variables.
func generateGoExterns(externs []*mkcgo.Extern, w io.Writer) {
	if len(externs) == 0 {
		return
	}
	fmt.Fprintf(w, "var (\n")
	for _, extern := range externs {
		fmt.Fprintf(w, "\t%s = C.%s\n", goSymName(extern.Name), extern.Name)
	}
	fmt.Fprintf(w, ")\n\n")
}

// generateGoEnums generates Go enum values for C enums.
func generateGoEnums(enums []*mkcgo.Enum, w io.Writer) {
	for _, enum := range enums {
		fmt.Fprintf(w, "const (\n")
		for _, enumValue := range enum.Values {
			fmt.Fprintf(w, "\t%s %s = %s\n", goSymName(enumValue.Name), enum.Type, enumValue.Value)
		}
		fmt.Fprintf(w, ")\n\n")
	}
}

// generateGoAliases generates Go type aliases for C types.
func generateGoAliases(funcs []*mkcgo.Func, externs []*mkcgo.Extern, enums []*mkcgo.Enum, w io.Writer) {
	// Traverse all functions and collect the unique C types.
	ctypes := make(map[string]struct{})
	handleType := func(typ string) {
		if typ == "" {
			return
		}
		typ = strings.TrimPrefix(typ, "const ")
		typ = strings.TrimRight(typ, "*")
		if _, ok := ctypes[typ]; ok {
			return
		}
		ctypes[typ] = struct{}{}
	}
	for _, fn := range funcs {
		for _, p := range fn.Params {
			if p.Variadic() {
				continue
			}
			handleType(p.Type)
		}
		handleType(fn.Ret)
	}
	for _, extern := range externs {
		handleType(extern.Type)
	}
	for _, enum := range enums {
		handleType(enum.Type)
	}
	types := make([]string, 0, len(ctypes))
	for typ := range ctypes {
		types = append(types, typ)
	}
	slices.Sort(types)
	for _, typ := range types {
		if isStdType(typ) {
			// Skip standard types.
			continue
		}
		fmt.Fprintf(w, "type %s = C.%s\n", goSymName(typ), typ)
	}
}

// generateCHeader generates C header file content with
// the C functions defined in the autogenerated C source file.
func generateCHeader(src *mkcgo.Source, w io.Writer) {
	// Header and includes.
	printHeader(w)

	fmt.Fprintf(w, "#ifndef MKCGO_H // only include this header once\n")
	fmt.Fprintf(w, "#define MKCGO_H\n\n")

	if *includeHeader != "" {
		fmt.Fprintf(w, "#include %q\n\n", *includeHeader)
	}

	// Source includes.
	for _, v := range src.Includes {
		fmt.Fprintf(w, "#include %s\n", v)
	}
	fmt.Fprintf(w, "\n")

	// Source types and enums.
	for _, def := range src.TypeDefs {
		fmt.Fprintf(w, "typedef %s %s;\n", def.Type, def.Name)
	}
	fmt.Fprintf(w, "\n")
	if len(src.Externs) > 0 {
		for _, def := range src.Externs {
			fmt.Fprintf(w, "extern %s %s;\n", def.Type, def.Name)
		}
		fmt.Fprintf(w, "\n")
	}
	for _, enum := range src.Enums {
		if enum.Type != "" {
			fmt.Fprintf(w, "typedef ")
		}
		fmt.Fprintf(w, "enum {\n")
		for _, enumValue := range enum.Values {
			fmt.Fprintf(w, "\t%s = %s,\n", enumValue.Name, enumValue.Value)
		}
		if enum.Type != "" {
			fmt.Fprintf(w, "} %s;", enum.Type)
		} else {
			fmt.Fprintf(w, "};")
		}
		fmt.Fprintf(w, "\n\n")
	}

	// Custom types
	fmt.Fprintf(w, "typedef void* %s;\n", mkcgoErrState)
	fmt.Fprintf(w, "%s mkcgo_err_retrieve();\n", mkcgoErrState)
	fmt.Fprintf(w, "void mkcgo_err_free(%s);\n", mkcgoErrState)
	fmt.Fprintf(w, "void mkcgo_err_clear();\n\n")

	if !*useDynamicLoading {
		// Add forward declarations for loader functions.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "void __mkcgo_load_%s(void* handle);\n", tag)
			fmt.Fprintf(w, "void __mkcgo_unload_%s();\n", tag)
		}
		fmt.Fprintf(w, "\n")
	}

	// Add forward declarations for optional functions.
	for _, fn := range src.Funcs {
		if fn.Optional {
			fmt.Fprintf(w, "int %s();\n", fnCNameAvailable(fn))
		}
	}
	fmt.Fprintf(w, "\n")

	// Add forward declarations for function wrappers returning errors.
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			// cgo doesn't support variadic functions, no need to include them.
			continue
		}
		if fnNeedErrWrapper(fn) {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fnCName(fn), fnCErrWrapperParams(fn, false))
		} else {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fnCName(fn), fnToCArgs(fn, true, false))
		}
	}
	fmt.Fprintf(w, "\n")
	fmt.Fprintf(w, "#endif // MKCGO_H\n")
}

// generateC creates the C source file content.
func generateC(src *mkcgo.Source, w io.Writer) {
	// Header and includes.
	printHeader(w)

	fmt.Fprintf(w, "#include <stddef.h>\n")
	fmt.Fprintf(w, "#include <stdlib.h>\n")
	fmt.Fprintf(w, "#include <stdint.h>\n")
	fmt.Fprintf(w, "#include <stdio.h>\n")
	if *includeHeader != "" {
		fmt.Fprintf(w, "#include %q\n", *includeHeader)
	}
	fmt.Fprintf(w, "#include \"%s\"\n", autogeneratedFileName(".h"))
	fmt.Fprintf(w, "\n")

	if !*useDynamicLoading {
		// Platform-specific includes.
		fmt.Fprintf(w, "#ifdef _WIN32\n")
		fmt.Fprintf(w, "#include <windows.h>\n")
		fmt.Fprintf(w, "#define dlsym GetProcAddress\n")
		fmt.Fprintf(w, "#else\n")
		fmt.Fprintf(w, "#include <dlfcn.h>\n")
		fmt.Fprintf(w, "#endif\n\n")
	}

	// Function pointer declarations.
	for _, fn := range src.Funcs {
		if fn.VariadicTarget != "" {
			continue
		}
		if !*useDynamicLoading {
			fmt.Fprintf(w, "%s (*_g_%s)(%s);\n", fn.Ret, fn.ImportName(), fnToCArgs(fn, true, false))
		} else {
			fmt.Fprintf(w, "%s %s(%s);\n", fn.Ret, fn.ImportName(), fnToCArgs(fn, true, false))
		}
	}
	fmt.Fprintf(w, "\n")
	if !*useDynamicLoading {
		fmt.Fprintf(w, "#define __mkcgo__dlsym_nocheck(varname, funcname) _g_##varname = (typeof(_g_##varname))dlsym(handle, #funcname);\n\n")
		fmt.Fprintf(w, "#define __mkcgo__dlsym(name) __mkcgo__dlsym2(name, name)\n\n")
		fmt.Fprintf(w, "#define __mkcgo__dlsym2(varname, funcname) \\\n")
		fmt.Fprintf(w, "\t__mkcgo__dlsym_nocheck(varname, funcname) \\\n")
		fmt.Fprintf(w, "\tif (_g_##varname == NULL) { \\\n")
		fmt.Fprintf(w, "\t\tfprintf(stderr, \"Cannot get required symbol \" #funcname \"\\n\"); \\\n")
		fmt.Fprintf(w, "\t\tabort(); \\\n")
		fmt.Fprintf(w, "\t}\n\n")

		// Loader and unloader functions for each tag.
		for _, tag := range src.Tags() {
			fmt.Fprintf(w, "void __mkcgo_load_%s(void* handle) {\n", tag)
			for _, fn := range src.Funcs {
				if fn.VariadicTarget != "" {
					continue
				}
				tags := fn.Tags
				if len(tags) == 0 {
					tags = []mkcgo.TagAttr{{}}
				}
				for _, tagAttr := range tags {
					if tagAttr.Tag == tag {
						if tagAttr.Name != "" {
							// TODO: if necessary, support optional functions in here too.
							fmt.Fprintf(w, "\t__mkcgo__dlsym2(%s, %s)\n", fn.ImportName(), tagAttr.Name)
						} else if fn.Optional {
							fmt.Fprintf(w, "\t__mkcgo__dlsym_nocheck(%s, %s)\n", fn.ImportName(), fn.ImportName())
						} else {
							fmt.Fprintf(w, "\t__mkcgo__dlsym(%s)\n", fn.ImportName())
						}
						break
					}
				}
			}
			fmt.Fprintf(w, "}\n\n")

			fmt.Fprintf(w, "void __mkcgo_unload_%s() {\n", tag)
			for _, fn := range src.Funcs {
				if fn.VariadicTarget != "" {
					continue
				}
				tags := fn.Tags
				if len(tags) == 0 {
					tags = []mkcgo.TagAttr{{}}
				}
				for _, tagAttr := range tags {
					if tagAttr.Tag == tag {
						fmt.Fprintf(w, "\t_g_%s = NULL;\n", fn.ImportName())
						break
					}
				}
			}
			fmt.Fprintf(w, "}\n\n")
		}
	}

	// Generate C function wrappers.
	typedefs := make(map[string]string, len(src.TypeDefs))
	for _, def := range src.TypeDefs {
		typedefs[def.Name] = def.Type
	}
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			// cgo doesn't support variadic functions, no need to include them.
			continue
		}
		if fn.Optional {
			// Generate a function that returns true if the function is available.
			fmt.Fprintf(w, "int %s() {\n", fnCNameAvailable(fn))
			fmt.Fprintf(w, "\treturn _g_%s != NULL;\n", fn.ImportName())
			fmt.Fprintf(w, "}\n\n")
		}
		generateCFn(typedefs, fn, w)
	}
}

// generateGoFn generates Go function f.
func generateGoFn(fn *mkcgo.Func, w io.Writer) {
	fnCall := fmt.Sprintf("C.%s(%s)", fnCName(fn), fnToGoArgs(fn))
	// Function definition
	fmt.Fprintf(w, "func %s(%s)", goSymName(fn.Name), fnToGoParams(fn))
	if isVoid(fn.Ret) {
		// Easy path, just call the C function. No need to write the return types,
		// nor do error handling, nor cast the return value.
		fmt.Fprintf(w, "{\n")
		fmt.Fprintf(w, "\t%s\n", fnCall)
		fmt.Fprintf(w, "}\n\n")
		return
	}
	goType, needCast := cTypeToGo(fn.Ret, false)
	if fn.NoError || !*errors {
		fmt.Fprintf(w, " %s ", goType)
	} else {
		fmt.Fprintf(w, " (%s, error) ", goType)
	}
	fmt.Fprintf(w, "{\n")

	// Function call
	var needUnsafeCast bool
	if needCast && goType[0] == '*' {
		goType = fmt.Sprintf("(%s)(unsafe.Pointer", goType)
		needUnsafeCast = true
	}
	if fn.NoError || !*errors {
		// No error handling, just cast the return value if necessary.
		fmt.Fprintf(w, "\treturn ")
		if needCast {
			fmt.Fprintf(w, "%s(%s)", goType, fnCall)
			if needUnsafeCast {
				fmt.Fprintf(w, ")")
			}
		} else {
			fmt.Fprintf(w, "%s", fnCall)
		}
		fmt.Fprintf(w, "\n")
		fmt.Fprintf(w, "}\n\n")
		return
	}
	fmt.Fprintf(w, "\tvar _err C.%s\n", mkcgoErrState)
	fmt.Fprintf(w, "\t_ret := C.%s(", fnCName(fn))
	args := fnToGoArgs(fn)
	if len(args) > 0 {
		args += ", "
	}
	fmt.Fprintf(w, "%s%s(&_err))\n", args, mkcgoNoEscape)

	// Return the value
	fmt.Fprintf(w, "\treturn ")
	if needCast {
		fmt.Fprintf(w, "%s(_ret)", goType)
		if needUnsafeCast {
			fmt.Fprintf(w, ")")
		}
	} else {
		fmt.Fprintf(w, "_ret")
	}
	fmt.Fprintf(w, ", newMkcgoErr(%q, _err)\n", fn.Name)
	fmt.Fprintf(w, "}\n\n")
}

func generateCFn(typedefs map[string]string, fn *mkcgo.Func, w io.Writer) {
	var prefix string
	if !*useDynamicLoading {
		prefix = "_g_"
	}
	if !fnNeedErrWrapper(fn) {
		fmt.Fprintf(w, "%s %s(%s) {\n\t", fn.Ret, fnCName(fn), fnToCArgs(fn, true, true))
		if !isVoid(fn.Ret) {
			fmt.Fprintf(w, "return ")
		}
		fmt.Fprintf(w, "%s%s(%s);\n", prefix, fn.ImportName(), fnToCArgs(fn, false, true))
		fmt.Fprintf(w, "}\n\n")
		return
	}

	fmt.Fprintf(w, "%s %s(%s) {\n", fn.Ret, fnCName(fn), fnCErrWrapperParams(fn, true))
	fmt.Fprintf(w, "\tmkcgo_err_clear();\n") // clear any previous error
	fmt.Fprintf(w, "\t%s _ret = %s%s(%s);\n", fn.Ret, prefix, fn.ImportName(), fnToCArgs(fn, false, true))
	errCond := "<= 0"
	if fn.ErrCond != "" {
		errCond = fn.ErrCond
	} else if strings.Contains(fn.Ret, "*") {
		errCond = "== NULL"
	} else if typ, ok := typedefs[fn.Ret]; ok && typ == "void*" {
		errCond = "== NULL"
	}
	fmt.Fprintf(w, "\tif (_ret %s) *_err_state = mkcgo_err_retrieve();\n", errCond)
	fmt.Fprintf(w, "\treturn _ret;\n")
	fmt.Fprintf(w, "}\n\n")
}

// paramToGo converts C parameter p to Go parameter.
func paramToGo(p *mkcgo.Param, hidden bool) string {
	goType, needCast := cTypeToGo(p.Type, true)
	if !needCast {
		if hidden && goType == "unsafe.Pointer" {
			// The parameter is not annotated with cgoCheckPointer by cgo
			// if it has the form unsafe.Pointer(&...).
			// See https://go-review.googlesource.com/c/go/+/404295.
			// TODO: support other types.
			return fmt.Sprintf("unsafe.Pointer(&*(*byte)(%s))", p.Name)
		}
		return p.Name
	}
	switch {
	case goType == "":
		return p.Name
	case goType[0] == '*':
		return fmt.Sprintf("(%s)(unsafe.Pointer(%s))", goType, p.Name)
	}
	return fmt.Sprintf("%s(%s)", goType, p.Name)
}

// isStdType reports whether t is a standard C type.
func isStdType(t string) bool {
	_, found := cstdTypesToGo[t]
	return found
}

// cstdTypesToGo maps C standard types to Go types.
var cstdTypesToGo = map[string]string{
	"int8_t":             "int8",
	"uint8_t":            "uint8",
	"int16_t":            "int16",
	"uint16_t":           "uint16",
	"int32_t":            "int32",
	"uint32_t":           "uint32",
	"int64_t":            "int64",
	"uint64_t":           "uint64",
	"int":                "int32",
	"unsigned":           "uint32",
	"unsigned int":       "uint32",
	"long":               "int64",
	"unsigned long":      "uint64",
	"long long":          "int64",
	"unsigned long long": "uint64",
	"size_t":             "int",
	"uintptr_t":          "uintptr",
	"char":               "byte",
	"unsigned char":      "byte",
	"signed char":        "int8",
	"void":               "",
}

// cstdTypesToCgo maps C standard types to special cgo types.
// Most C don't need any special handling, only the ones that have spaces.
var cstdTypesToCgo = map[string]string{
	"signed char":        "schar",
	"unsigned":           "uint",
	"unsigned char":      "uchar",
	"unsigned short":     "ushort",
	"unsigned int":       "uint",
	"unsigned long":      "ulong",
	"long long":          "longlong",
	"unsigned long long": "ulonglong",
}

// cTypeToGo converts C type t to a Go type.
// If cgo is true, it returns the type that can be
// passed to a cgo function call.
// It returns the Go type and a boolean that reports whether
// the type needs to be casted to goType or not.
func cTypeToGo(t string, cgo bool) (string, bool) {
	t, _ = strings.CutPrefix(t, "const ")
	if isVoid(t) {
		return "", true
	}
	if strings.HasPrefix(t, "void*") {
		n := strings.Count(t, "*")
		return strings.Repeat("*", n-1) + "unsafe.Pointer", false
	}
	if strings.HasSuffix(t, "*") {
		// Remove all trailing '*' characters.
		var i, n int
		for i = len(t) - 1; i >= 0; i-- {
			if t[i] != '*' {
				break
			}
			n++
		}
		s, std := cTypeToGo(t[:i+1], cgo)
		if s != "" {
			s = strings.Repeat("*", n) + s
		}
		return s, std
	}
	if !isStdType(t) {
		return goSymName(t), false
	}
	if cgo {
		if s, ok := cstdTypesToCgo[t]; ok {
			t = s
		}
		return "C." + t, true
	}
	if t, ok := cstdTypesToGo[t]; ok {
		return t, true
	}
	return t, true
}

// paramToC returns C source code of parameter p.
func paramToC(i int, p *mkcgo.Param, addType, addName bool) string {
	if p.Type == "..." {
		return "..."
	}
	var s string
	if addType {
		s += p.Type
	}
	if addName && !isVoid(p.Type) {
		if len(s) > 0 {
			s += " "
		}
		s += "_arg" + strconv.Itoa(i)
	}
	return s
}

// isVoid reports whether typ is a void type.
func isVoid(typ string) bool {
	return typ == "void"
}

// fnToGoParams returns source code for function f parameters.
func fnToGoParams(fn *mkcgo.Func) string {
	return join(fn.Params, func(_ int, p *mkcgo.Param) string {
		typ, _ := cTypeToGo(p.Type, false)
		return p.Name + " " + typ
	}, ", ")
}

// argList returns source code for C parameters for function f.
func fnToGoArgs(fn *mkcgo.Func) string {
	return join(fn.Params, func(_ int, p *mkcgo.Param) string {
		return paramToGo(p, slices.Contains(fn.NoCheckPtrParams, p.Name))
	}, ", ")
}

// fnToCArgs returns source code for C parameters for function f.
func fnToCArgs(fn *mkcgo.Func, addType, addName bool) string {
	return join(fn.Params, func(i int, p *mkcgo.Param) string {
		return paramToC(i, p, addType, addName)
	}, ", ")
}

// join concatenates parameters ps into a string with sep separator.
// Each parameter is converted into string by applying fn to it
// before conversion.
func join(ps []*mkcgo.Param, fn func(int, *mkcgo.Param) string, sep string) string {
	if len(ps) == 0 {
		return ""
	}
	params := make([]string, 0, len(ps))
	for i, p := range ps {
		param := fn(i, p)
		if param != "" {
			params = append(params, param)
		}
	}
	return strings.Join(params, sep)
}

const mkcgoNoEscape = "mkcgoNoEscape"
const mkcgoErrState = "mkcgo_err_state"

// fnCErrWrapperParams returns source code for C parameters for function f
// with the error state added as the last parameter.
func fnCErrWrapperParams(fn *mkcgo.Func, addName bool) string {
	errArg := mkcgoErrState + " *"
	if addName {
		errArg += "_err_state"
	}
	args := fnToCArgs(fn, true, addName)
	if len(args) == 0 {
		args = errArg
	} else if isVoid(args) {
		args = errArg
	} else {
		args += ", " + errArg
	}
	return args
}

func fnGoNameAvailable(fn *mkcgo.Func) string {
	return goSymName(fn.Name) + "_Available"
}

// fnCName returns the C function name for function f.
func fnCName(fn *mkcgo.Func) string {
	return "_mkcgo_" + fn.Name
}

// fnCNameAvailable returns the C function name for function f
// that checks if the function is available.
func fnCNameAvailable(fn *mkcgo.Func) string {
	return "_mkcgo_available_" + fn.Name
}

// fnNeedErrWrapper reports whether function fn needs an error wrapper.
func fnNeedErrWrapper(fn *mkcgo.Func) bool {
	return *errors && !fn.NoError && !isVoid(fn.Ret)
}

// fnCalledFromGo reports whether function fn is called from Go code.
func fnCalledFromGo(fn *mkcgo.Func) bool {
	return !fn.Variadic() // cgo doesn't support variadic functions
}

// goSymName returns the Go symbol name for a C symbol name.
// The returned name can be transformed depending on the
// value of the private flag.
func goSymName(name string) string {
	if name == "" {
		panic("empty name")
	}
	ch, _ := utf8.DecodeRuneInString(name)
	isPrivate := !unicode.IsUpper(ch)
	if *private == isPrivate {
		// Same access level, no need to change.
		return name
	}
	if !isPrivate {
		// Exported name, make it private by adding an underscore.
		return "_" + name
	}
	// Unexported name, make it exported.
	if name[0] == '_' {
		// If it starts with an underscore, remove it
		// and try again.
		name = strings.TrimPrefix(name, "_")
		return goSymName(name)
	}
	// Uppercase the first letter.
	return strings.ToUpper(name[:1]) + name[1:]
}

// getFrameworkPath returns the framework path for a given symbol name.
func getFrameworkPath(symbolName string) string {
	switch {
	case strings.Contains(symbolName, "CF"):
		return "/System/Library/Frameworks/CoreFoundation.framework/Versions/A/CoreFoundation"
	case strings.Contains(symbolName, "CC"):
		return "/usr/lib/libSystem.B.dylib"
	case strings.Contains(symbolName, "Sec"):
		return "/System/Library/Frameworks/Security.framework/Versions/A/Security"
	default:
		panic("unknown symbol: " + symbolName)
	}
}

// generateNocgoGo generates Go source file for nocgo mode from src.
func generateNocgoGo(src *mkcgo.Source, w io.Writer) {
	// Output header notice and package declaration.
	printHeader(w)
	fmt.Fprintf(w, "//go:build !cgo && darwin\n\n")
	fmt.Fprintf(w, "package %s\n\n", *packageName)

	// Check if we need syscallN (functions with more than 9 parameters)
	needsSyscallN := false
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}
		if len(fn.Params) > 9 {
			needsSyscallN = true
			break
		}
	}

	// Import necessary packages for nocgo mode
	fmt.Fprintf(w, "import (\n")
	fmt.Fprintf(w, "\t\"syscall\"\n")
	fmt.Fprintf(w, "\t\"unsafe\"\n")
	fmt.Fprintf(w, ")\n\n")

	// Generate linkname declarations for syscall functions
	fmt.Fprintf(w, "//go:linkname syscall_syscall syscall.syscall\n")
	fmt.Fprintf(w, "//go:linkname syscall_syscall6 syscall.syscall6\n")
	fmt.Fprintf(w, "//go:linkname syscall_syscall9 syscall.syscall9\n")
	if needsSyscallN {
		fmt.Fprintf(w, "//go:linkname entersyscall runtime.entersyscall\n")
		fmt.Fprintf(w, "//go:linkname exitsyscall runtime.exitsyscall\n")
	}
	fmt.Fprintf(w, "\n")

	// Generate function signatures for syscall functions
	fmt.Fprintf(w, "func syscall_syscall(fn, a1, a2, a3 uintptr) (r1, r2 uintptr, err syscall.Errno)\n")
	fmt.Fprintf(w, "func syscall_syscall6(fn, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2 uintptr, err syscall.Errno)\n")
	fmt.Fprintf(w, "func syscall_syscall9(fn, a1, a2, a3, a4, a5, a6, a7, a8, a9 uintptr) (r1, r2 uintptr, err syscall.Errno)\n")
	if needsSyscallN {
		fmt.Fprintf(w, "func entersyscall()\n")
		fmt.Fprintf(w, "func exitsyscall()\n")
	}
	fmt.Fprintf(w, "\n")

	// Generate cgo_import_dynamic directives for extern variables
	for _, ext := range src.Externs {
		extName := ext.Name
		frameworkPath := getFrameworkPath(extName)
		fmt.Fprintf(w, "//go:cgo_import_dynamic _mkcgo_%s %s \"%s\"\n", extName, extName, frameworkPath)
		fmt.Fprintf(w, "//go:linkname _mkcgo_%s _mkcgo_%s\n", extName, extName)
	}
	fmt.Fprintf(w, "\n")

	// Generate cgo_import_dynamic directives for each function
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}
		fnName := fn.Name
		frameworkPath := getFrameworkPath(fnName)
		fmt.Fprintf(w, "//go:cgo_import_dynamic _mkcgo_%s %s \"%s\"\n", fnName, fnName, frameworkPath)
	}
	fmt.Fprintf(w, "\n")

	// Generate all type aliases (from externs, functions, and typedefs)
	generateNocgoAllAliases(src.Externs, src.Funcs, src.TypeDefs, w)

	// Generate enums
	generateNocgoEnums(src.Enums, w)

	// Generate extern variables
	generateNocgoExterns(src.Externs, w)

	// Generate trampoline address variables and wrapper functions
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}
		generateNocgoFn(fn, w)
	}
}

// generateNocgoAllAliases generates Go type aliases for nocgo mode from both externs and function signatures.
func generateNocgoAllAliases(externs []*mkcgo.Extern, funcs []*mkcgo.Func, typedefs []*mkcgo.TypeDef, w io.Writer) {
	seenTypes := make(map[string]bool)

	// Handle typedefs first, as they can create proper type aliases
	for _, typedef := range typedefs {
		baseType := extractBaseType(typedef.Type)
		if needsTypeAlias(baseType) {
			fmt.Fprintf(w, "type %s = %s\n", typedef.Name, baseType)
			seenTypes[typedef.Name] = true
		} else {
			// For basic types, make it an alias to the appropriate Go type
			goType := convertCTypeToNocgoType(typedef.Type)
			if goType != "" && goType != "unsafe.Pointer" {
				fmt.Fprintf(w, "type %s = %s\n", typedef.Name, goType)
				seenTypes[typedef.Name] = true
			} else {
				fmt.Fprintf(w, "type %s unsafe.Pointer\n", typedef.Name)
				seenTypes[typedef.Name] = true
			}
		}
	}

	// Extract types from extern variables
	for _, ext := range externs {
		baseType := extractBaseType(ext.Type)
		if baseType != "void" && !seenTypes[baseType] {
			fmt.Fprintf(w, "type %s unsafe.Pointer\n", baseType)
			seenTypes[baseType] = true
		}
	}

	// Extract types from function signatures
	for _, fn := range funcs {
		if !fnCalledFromGo(fn) {
			continue
		}

		// Extract types from function parameters
		for _, param := range fn.Params {
			baseType := extractBaseType(param.Type)
			if needsTypeAlias(baseType) && !seenTypes[baseType] {
				fmt.Fprintf(w, "type %s unsafe.Pointer\n", baseType)
				seenTypes[baseType] = true
			}
			// Handle standard C types that need aliases
			if baseType == "unsigned" && !seenTypes["Unsigned"] {
				fmt.Fprintf(w, "type Unsigned uint32\n")
				seenTypes["Unsigned"] = true
			}
		}

		// Extract type from return value
		if fn.Ret != "" && fn.Ret != "void" {
			baseType := extractBaseType(fn.Ret)
			if needsTypeAlias(baseType) && !seenTypes[baseType] {
				fmt.Fprintf(w, "type %s unsafe.Pointer\n", baseType)
				seenTypes[baseType] = true
			}
		}
	}

	fmt.Fprintf(w, "\n")
}

// generateNocgoEnums generates Go enum values for nocgo mode.
func generateNocgoEnums(enums []*mkcgo.Enum, w io.Writer) {
	for _, enum := range enums {
		if enum.Type != "" {
			// Generate the type alias
			fmt.Fprintf(w, "type %s int32\n\n", enum.Type)
		}

		fmt.Fprintf(w, "const (\n")
		for _, enumValue := range enum.Values {
			if enum.Type != "" {
				fmt.Fprintf(w, "\t%s %s = %s\n", goSymName(enumValue.Name), enum.Type, enumValue.Value)
			} else {
				fmt.Fprintf(w, "\t%s = %s\n", goSymName(enumValue.Name), enumValue.Value)
			}
		}
		fmt.Fprintf(w, ")\n\n")
	}
}

// extractBaseType extracts the base type name from a C type string.
func extractBaseType(cType string) string {
	cType = strings.TrimSpace(cType)
	cType = strings.TrimPrefix(cType, "const ")
	cType = strings.TrimSuffix(cType, "*")
	cType = strings.TrimSpace(cType)
	return cType
}

// needsTypeAlias returns true if the type needs a type alias definition.
func needsTypeAlias(baseType string) bool {
	return strings.HasSuffix(baseType, "Ref") ||
		baseType == "SecKeyAlgorithm" ||
		baseType == "CFDictionaryKeyCallBacks" ||
		baseType == "CFDictionaryValueCallBacks"
}

// generateNocgoExterns generates Go extern variables for nocgo mode.
func generateNocgoExterns(externs []*mkcgo.Extern, w io.Writer) {
	if len(externs) == 0 {
		return
	}

	// First, generate pointer variables for extern symbols
	fmt.Fprintf(w, "var (\n")
	for _, ext := range externs {
		// Use the base type without pointer and const
		baseType := strings.TrimPrefix(ext.Type, "*")
		baseType = strings.TrimPrefix(baseType, "const ")
		fmt.Fprintf(w, "\t_mkcgo_%s %s\n", ext.Name, baseType)
	}
	fmt.Fprintf(w, ")\n\n")

	for _, ext := range externs {
		// Use the base type without pointer and const
		baseType := strings.TrimPrefix(ext.Type, "*")
		baseType = strings.TrimPrefix(baseType, "const ")
		fmt.Fprintf(w, "//go:noinline\n")
		fmt.Fprintf(w, "func _mkcgo_addr_%s() *%s { return &_mkcgo_%s }\n", ext.Name, baseType, ext.Name)
	}

	// Then, generate the actual variables that dereference the pointers
	fmt.Fprintf(w, "var (\n")
	for _, ext := range externs {
		// Convert extern names to Go variable names
		goName := ext.Name
		if strings.HasPrefix(goName, "k") {
			// Convert kSecRandomDefault to KSecRandomDefault
			goName = "K" + goName[1:]
		}

		// Use the base type without pointer and const
		baseType := strings.TrimPrefix(ext.Type, "*")
		baseType = strings.TrimPrefix(baseType, "const ")

		fmt.Fprintf(w, "\t%s %s = *_mkcgo_addr_%s()\n", goName, baseType, ext.Name)
	}
	fmt.Fprintf(w, ")\n\n")
}

// generateNocgoFn generates Go function wrapper for nocgo mode.
func generateNocgoFn(fn *mkcgo.Func, w io.Writer) {
	fnName := fn.Name
	goFnName := goSymName(fn.Name)
	trampolineName := fmt.Sprintf("_mkcgo_%s_trampoline_addr", fnName)

	// Generate trampoline address variable
	fmt.Fprintf(w, "var %s uintptr\n\n", trampolineName)

	// Generate Go wrapper function
	fmt.Fprintf(w, "func %s(", goFnName)

	// Generate parameters
	for i, param := range fn.Params {
		if i > 0 {
			fmt.Fprintf(w, ", ")
		}

		// Convert C types to Go types for nocgo mode
		goType := convertCTypeToNocgoType(param.Type)
		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("arg%d", i)
		}
		fmt.Fprintf(w, "%s %s", paramName, goType)
	}
	fmt.Fprintf(w, ")")

	// Generate return type
	if fn.Ret != "" && fn.Ret != "void" {
		goRetType := convertCTypeToNocgoType(fn.Ret)
		fmt.Fprintf(w, " %s", goRetType)
	}

	fmt.Fprintf(w, " {\n")

	// Generate syscall invocation
	numParams := len(fn.Params)
	var syscallFunc string
	var maxArgs int
	if numParams <= 3 {
		syscallFunc = "syscall_syscall"
		maxArgs = 3
	} else if numParams <= 6 {
		syscallFunc = "syscall_syscall6"
		maxArgs = 6
	} else if numParams <= 9 {
		syscallFunc = "syscall_syscall9"
		maxArgs = 9
	} else {
		syscallFunc = "syscallN"
		maxArgs = numParams
	}

	// Generate the syscall invocation with proper argument handling
	if syscallFunc == "syscallN" {
		if fn.Ret != "" && fn.Ret != "void" {
			fmt.Fprintf(w, "\tr0, _, _ := %s(%s", syscallFunc, trampolineName)
		} else {
			fmt.Fprintf(w, "\t%s(%s", syscallFunc, trampolineName)
		}
	} else {
		if fn.Ret != "" && fn.Ret != "void" {
			fmt.Fprintf(w, "\tr0, _, _ := %s(%s", syscallFunc, trampolineName)
		} else {
			fmt.Fprintf(w, "\t%s(%s", syscallFunc, trampolineName)
		}
	}

	// Add actual parameters
	skipNext := false
	for i, param := range fn.Params {
		if i >= maxArgs {
			break // Skip parameters beyond what the syscall function can handle
		}

		// Skip this parameter if it was already handled in the previous iteration
		if skipNext {
			skipNext = false
			continue
		}

		paramName := param.Name
		if paramName == "" {
			paramName = fmt.Sprintf("arg%d", i)
		}

		// Special handling for CCCryptorCreateWithMode: combine numRounds and options into a single parameter
		if fn.Name == "CCCryptorCreateWithMode" && syscallFunc == "syscallN" && i == 9 && len(fn.Params) > 10 {
			// This is the numRounds parameter (index 9), and we have options at index 10
			// Combine them: numRounds<<32 | options
			nextParam := fn.Params[10]
			nextParamName := nextParam.Name
			if nextParamName == "" {
				nextParamName = fmt.Sprintf("arg%d", 10)
			}
			fmt.Fprintf(w, ", uintptr(%s)<<32|uintptr(%s)", paramName, nextParamName)
			// Skip the next parameter since we've already handled it
			skipNext = true
			continue
		}

		// Convert parameter to uintptr, handling different types correctly
		goType := convertCTypeToNocgoType(param.Type)
		if strings.HasPrefix(goType, "*") {
			// Pointer types need to go through unsafe.Pointer
			fmt.Fprintf(w, ", uintptr(unsafe.Pointer(%s))", paramName)
		} else if goType == "int32" || goType == "int" || strings.Contains(goType, "CC") {
			// Enum types and integers can be cast directly to uintptr
			fmt.Fprintf(w, ", uintptr(%s)", paramName)
		} else {
			// Other types
			fmt.Fprintf(w, ", uintptr(%s)", paramName)
		}
	}

	// Pad with zeros to reach the required argument count
	for i := numParams; i < maxArgs; i++ {
		fmt.Fprintf(w, ", 0")
	}
	fmt.Fprintf(w, ")\n")

	// Generate return statement
	if fn.Ret != "" && fn.Ret != "void" {
		goRetType := convertCTypeToNocgoType(fn.Ret)
		if strings.HasPrefix(goRetType, "*") {
			// Pointer return types need to go through unsafe.Pointer
			fmt.Fprintf(w, "\treturn (%s)(unsafe.Pointer(r0))\n", goRetType)
		} else if goRetType == "int32" || goRetType == "int" || strings.Contains(goRetType, "CC") {
			// Enum types and integers can be cast directly from uintptr
			fmt.Fprintf(w, "\treturn %s(r0)\n", goRetType)
		} else {
			fmt.Fprintf(w, "\treturn %s(r0)\n", goRetType)
		}
	}

	fmt.Fprintf(w, "}\n\n")
}

// convertCTypeToNocgoType converts C types to appropriate Go types for nocgo mode.
func convertCTypeToNocgoType(cType string) string {
	cType = strings.TrimSpace(cType)
	originalType := cType

	// Remove const and pointer prefixes to get the base type
	baseType := strings.TrimPrefix(cType, "const ")
	baseType = strings.TrimSpace(baseType)

	// Count and remove all trailing asterisks
	pointerCount := 0
	for strings.HasSuffix(baseType, "*") {
		pointerCount++
		baseType = strings.TrimSuffix(baseType, "*")
		baseType = strings.TrimSpace(baseType)
	}

	switch {
	case originalType == "void":
		return ""
	case originalType == "int" || originalType == "int32_t":
		return "int32"
	case originalType == "unsigned" || originalType == "unsigned int":
		return "uint32"
	case originalType == "uint32_t":
		return "uint32"
	case originalType == "size_t":
		return "int"
	case originalType == "size_t*" || (baseType == "size_t" && pointerCount == 1):
		return "*int"
	case originalType == "Boolean":
		return "int32"
	case baseType == "CCModeOptions":
		// CCModeOptions is uint32_t
		if pointerCount > 0 {
			return "*uint32"
		}
		return "uint32"
	case baseType == "CCOperation" || baseType == "CCAlgorithm" || baseType == "CCCryptorStatus" ||
		baseType == "CCMode" || baseType == "CCOptions" || baseType == "CCPadding" ||
		baseType == "CCPBKDFAlgorithm" || baseType == "CCPseudoRandomAlgorithm":
		// These are enum types that should remain as their proper type
		if pointerCount > 0 {
			return "*" + baseType
		}
		return baseType
	case baseType == "SecRandomRef" || baseType == "SecKeyRef" || baseType == "CFDataRef" ||
		baseType == "CFTypeRef" || baseType == "CFStringRef" || baseType == "CFDictionaryRef" ||
		baseType == "CFMutableDictionaryRef" || baseType == "CFNumberRef" || baseType == "CFErrorRef" ||
		baseType == "CFAllocatorRef" || baseType == "SecKeyAlgorithm" || baseType == "SecKeyOperationType" ||
		baseType == "CFIndex" || baseType == "CFDictionaryKeyCallBacks" || baseType == "CFDictionaryValueCallBacks" ||
		baseType == "CFNumberType" || baseType == "CFStringEncoding" || baseType == "CCCryptorRef":
		// Use the type name directly for these framework types
		if pointerCount > 0 {
			return "*" + baseType
		}
		return baseType
	case baseType == "uint8_t":
		if pointerCount > 0 {
			return "*uint8"
		}
		return "uint8"
	case baseType == "byte":
		if pointerCount > 0 {
			return "*byte"
		}
		return "byte"
	case baseType == "char":
		if pointerCount > 0 {
			return "*byte"
		}
		return "byte"
	case baseType == "void":
		if pointerCount >= 2 {
			// Double pointer (void **) becomes *unsafe.Pointer
			return "*unsafe.Pointer"
		} else if pointerCount == 1 {
			return "unsafe.Pointer"
		}
		return ""
	case pointerCount > 0:
		return "unsafe.Pointer"
	default:
		return "unsafe.Pointer"
	}
}

// generateAssembly generates the assembly trampoline file for nocgo mode.
func generateAssembly(src *mkcgo.Source, w io.Writer) {
	printHeader(w)
	fmt.Fprintf(w, "//go:build !cgo\n\n")
	fmt.Fprintf(w, "#include \"textflag.h\"\n \n")

	// Generate trampolines for each function
	for _, fn := range src.Funcs {
		if !fnCalledFromGo(fn) {
			continue
		}

		fnName := fn.Name
		fmt.Fprintf(w, "TEXT _mkcgo_%s_trampoline<>(SB),NOSPLIT,$0-0\n", fnName)
		fmt.Fprintf(w, "    JMP _mkcgo_%s(SB)\n", fnName)
		fmt.Fprintf(w, "GLOBL   ·_mkcgo_%s_trampoline_addr(SB), RODATA, $8\n", fnName)
		fmt.Fprintf(w, "DATA    ·_mkcgo_%s_trampoline_addr(SB)/8, $_mkcgo_%s_trampoline<>(SB)\n\n", fnName, fnName)
	}
}
