// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"bytes"
	"cmp"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/microsoft/go-crypto-darwin/internal/mkcgo"
)

var (
	fileName      = flag.String("out", "", "output file name (standard output if omitted)")
	includeHeader = flag.String("include", "", "include header file")
	packageName   = flag.String("package", "", "package name")
	nocgo         = flag.Bool("nocgo", false, "don't use cgo")
	mode          = flag.String("mode", "dynamic", "symbol load mode: dynamic, dynload")
	private       = flag.Bool("private", false, "all Go generated symbols are kept unexported")
	noerrors      = flag.Bool("noerrors", false, "disable error handling")
)

func usage() {
	fmt.Fprintf(os.Stderr, "usage: mkcgo [flags] [path ...]\n")
	flag.PrintDefaults()
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func dynamic() bool {
	return *mode == "dynamic"
}

func dynload() bool {
	return *mode == "dynload"
}

func main() {
	// Set up and parse flags.
	flag.Usage = usage
	flag.Parse()
	if len(flag.Args()) == 0 {
		fmt.Fprintln(os.Stderr, "no files to parse provided")
		usage()
	}

	var src mkcgo.Source
	// Parse source files.
	for _, arg := range flag.Args() {
		file, err := os.Open(arg)
		if err != nil {
			log.Fatal(err)
		}
		err = src.Parse(file)
		file.Close()
		if err != nil {
			log.Fatal(err)
		}
	}

	// Sort functions by name to get deterministic output
	// even when the order of the functions in the source file changes.
	slices.SortFunc(src.Funcs, func(a, b *mkcgo.Func) int {
		return cmp.Compare(a.Name, b.Name)
	})

	if *nocgo {
		// Determine if this is a zdl file for special handling
		baseNameForCheck := *fileName
		if baseNameForCheck == "" {
			baseNameForCheck = "mkcgo"
		} else {
			baseNameForCheck = strings.TrimSuffix(baseNameForCheck, ".go")
		}
		isZdlFile := strings.HasPrefix(baseNameForCheck, "zdl")

		// Generate nocgo mode files
		var nocgoGoBuffer, assemblyBuffer bytes.Buffer
		generateNocgoGo(&src, &nocgoGoBuffer, isZdlFile)

		// Only generate assembly if needed (i.e., not all functions are static)
		needsAsm := needsAssembly(&src)
		if needsAsm {
			generateAssembly(&src, &assemblyBuffer)
		}

		// Format the generated Go source code.
		nocgoGoData := goformat(nocgoGoBuffer.Bytes())

		// Determine suffix based on the base name
		suffix := "_nocgo.go"

		// Special case for zdl files - use _nocgo_unix.go suffix
		if isZdlFile {
			suffix = "_nocgo_unix.go"
		}

		files := []struct {
			suffix string
			data   []byte
		}{
			{suffix, nocgoGoData},
		}

		// Only add assembly file if needed
		if needsAsm {
			files = append(files, struct {
				suffix string
				data   []byte
			}{".s", assemblyBuffer.Bytes()})
		}

		for _, d := range files {
			name := autogeneratedFileName(d.suffix)
			var err error
			if *fileName == "" {
				// Write output. If no explicit output file is specified,
				// write both Go and assembly output to stdout.
				os.Stdout.WriteString("// === " + name + " ===\n\n")
				_, err = os.Stdout.Write(d.data)
			} else {
				err = os.WriteFile(name, d.data, 0o644)
			}
			if err != nil {
				log.Fatal(err)
			}
		}

		return
	}

	var gobuf, go124buf, hbuf, cbuf bytes.Buffer
	generateGo(&src, &gobuf)
	generateGo124(&src, &go124buf)
	generateCHeader(&src, &hbuf)
	generateC(&src, &cbuf)

	// Format the generated Go source code.
	godata := goformat(gobuf.Bytes())
	go124data := goformat(go124buf.Bytes())

	for _, d := range []struct {
		suffix string
		data   []byte
	}{
		{".go", godata},
		{"_go124.go", go124data},
		{".h", hbuf.Bytes()},
		{".c", cbuf.Bytes()},
	} {
		name := autogeneratedFileName(d.suffix)
		var err error
		if *fileName == "" {
			// Write output. If no explicit output file is specified,
			// // write both Go and C output to stdout.
			os.Stdout.WriteString("// === " + name + " ===\n\n")
			_, err = os.Stdout.Write(d.data)
		} else {
			err = os.WriteFile(name, d.data, 0o644)
		}
		if err != nil {
			log.Fatal(err)
		}
	}
}

// autogeneratedFileName returns the name of the autogenerated file
// using the provided suffix.
func autogeneratedFileName(suffix string) string {
	var baseName string
	if *fileName == "" {
		baseName = "mkcgo"
	} else {
		baseName = strings.TrimSuffix(*fileName, ".go")
	}
	return baseName + suffix
}

func writeTempSourceFile(data []byte) (string, error) {
	f, err := os.CreateTemp("", "mkcgo-generated-*.go")
	if err != nil {
		return "", err
	}
	_, err = f.Write(data)
	if closeErr := f.Close(); err == nil {
		err = closeErr
	}
	if err != nil {
		os.Remove(f.Name()) // best effort
		return "", err
	}
	return f.Name(), nil
}

func goformat(data []byte) []byte {
	fdata, err := format.Source(data)
	if err != nil {
		log.Printf("failed to format source: %v", err)
		f, err := writeTempSourceFile(data)
		if err != nil {
			log.Fatalf("failed to write unformatted source to file: %v", err)
		}
		log.Fatalf("for diagnosis, wrote unformatted source to %v", f)
	}
	return fdata
}
