// Code generated by mkcgo. DO NOT EDIT.

package commoncrypto

/*
#cgo CFLAGS: -Wno-attributes
#include "zcommoncrypto.h"
*/
import "C"
import "unsafe"

const (
	KCCEncrypt CCOperation = 0
	KCCDecrypt CCOperation = 1
)

const (
	KCCModeCBC CCMode = 2
)

const (
	KCCOptionECBMode CCOptions = 2
)

const (
	KCCSuccess CCCryptorStatus = 0
)

const (
	KCCPBKDF2 CCPBKDFAlgorithm = 2
)

const (
	KCCPRFHmacAlgSHA1   CCPseudoRandomAlgorithm = 1
	KCCPRFHmacAlgSHA256 CCPseudoRandomAlgorithm = 3
	KCCPRFHmacAlgSHA384 CCPseudoRandomAlgorithm = 4
	KCCPRFHmacAlgSHA512 CCPseudoRandomAlgorithm = 5
)

const (
	KCCBlockSizeAES128 = 16
	KCCBlockSizeDES    = 8
)

const (
	CcNoPadding CCPadding = 0
)

const (
	KCCAlgorithmAES  CCAlgorithm = 0
	KCCAlgorithmDES  CCAlgorithm = 1
	KCCAlgorithm3DES CCAlgorithm = 2
	KCCAlgorithmRC4  CCAlgorithm = 4
)

type CCAlgorithm = C.CCAlgorithm
type CCCryptorRef = C.CCCryptorRef
type CCCryptorStatus = C.CCCryptorStatus
type CCMode = C.CCMode
type CCModeOptions = C.CCModeOptions
type CCOperation = C.CCOperation
type CCOptions = C.CCOptions
type CCPBKDFAlgorithm = C.CCPBKDFAlgorithm
type CCPadding = C.CCPadding
type CCPseudoRandomAlgorithm = C.CCPseudoRandomAlgorithm
type Unsigned = C.unsigned

//go:nosplit
func mkcgoNoEscape(p *C.mkcgo_err_state) *C.mkcgo_err_state {
	x := uintptr(unsafe.Pointer(p))
	return (*C.mkcgo_err_state)(unsafe.Pointer(x ^ 0))
}

func CCCrypt(op CCOperation, alg CCAlgorithm, options CCOptions, key unsafe.Pointer, keyLength int, iv unsafe.Pointer, dataIn unsafe.Pointer, dataInLength int, dataOut unsafe.Pointer, dataOutAvailable int, dataOutMoved *int) CCCryptorStatus {
	return C._mkcgo_CCCrypt(op, alg, options, key, C.size_t(keyLength), iv, dataIn, C.size_t(dataInLength), dataOut, C.size_t(dataOutAvailable), (*C.size_t)(unsafe.Pointer(dataOutMoved)))
}

func CCCryptorCreate(op CCOperation, alg CCAlgorithm, options CCOptions, key unsafe.Pointer, keyLength int, iv unsafe.Pointer, cryptorRef *CCCryptorRef) CCCryptorStatus {
	return C._mkcgo_CCCryptorCreate(op, alg, options, key, C.size_t(keyLength), iv, cryptorRef)
}

func CCCryptorCreateWithMode(op CCOperation, mode CCMode, alg CCAlgorithm, padding CCPadding, iv unsafe.Pointer, key unsafe.Pointer, keyLength int, tweak unsafe.Pointer, tweakLength int, numRounds int32, options CCModeOptions, cryptorRef *CCCryptorRef) CCCryptorStatus {
	return C._mkcgo_CCCryptorCreateWithMode(op, mode, alg, padding, iv, key, C.size_t(keyLength), tweak, C.size_t(tweakLength), C.int(numRounds), options, cryptorRef)
}

func CCCryptorRelease(cryptorRef CCCryptorRef) CCCryptorStatus {
	return C._mkcgo_CCCryptorRelease(cryptorRef)
}

func CCCryptorReset(cryptorRef CCCryptorRef, iv unsafe.Pointer) CCCryptorStatus {
	return C._mkcgo_CCCryptorReset(cryptorRef, iv)
}

func CCCryptorUpdate(cryptorRef CCCryptorRef, dataIn unsafe.Pointer, dataInLength int, dataOut unsafe.Pointer, dataOutAvailable int, dataOutMoved *int) CCCryptorStatus {
	return C._mkcgo_CCCryptorUpdate(cryptorRef, dataIn, C.size_t(dataInLength), dataOut, C.size_t(dataOutAvailable), (*C.size_t)(unsafe.Pointer(dataOutMoved)))
}

func CCKeyDerivationPBKDF(algorithm CCPBKDFAlgorithm, password *byte, passwordLen int, salt *uint8, saltLen int, prf CCPseudoRandomAlgorithm, rounds Unsigned, derivedKey *uint8, derivedKeyLen int) CCCryptorStatus {
	return C._mkcgo_CCKeyDerivationPBKDF(algorithm, (*C.char)(unsafe.Pointer(password)), C.size_t(passwordLen), (*C.uint8_t)(unsafe.Pointer(salt)), C.size_t(saltLen), prf, rounds, (*C.uint8_t)(unsafe.Pointer(derivedKey)), C.size_t(derivedKeyLen))
}
