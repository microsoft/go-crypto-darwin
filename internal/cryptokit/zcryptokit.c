// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// Code generated by mkcgo. DO NOT EDIT.

#include <stddef.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdio.h>
#include "zcryptokit.h"

void MD5(const uint8_t*, size_t, const uint8_t*);
void SHA1(const uint8_t*, size_t, const uint8_t*);
void SHA256(const uint8_t*, size_t, const uint8_t*);
void SHA384(const uint8_t*, size_t, const uint8_t*);
void SHA512(const uint8_t*, size_t, const uint8_t*);
void* copyHMAC(int32_t, void*);
int decryptAESGCM(const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, uint8_t*, size_t*);
int encryptAESGCM(const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, const uint8_t*, size_t, uint8_t*, size_t, uint8_t*);
int expandHKDF(int32_t, const uint8_t*, size_t, const uint8_t*, size_t, uint8_t*, size_t);
int extractHKDF(int32_t, const uint8_t*, size_t, const uint8_t*, size_t, uint8_t*, size_t);
void finalizeHMAC(int32_t, void*, uint8_t*);
void freeHMAC(int32_t, void*);
void generateKeyEd25519(uint8_t*);
int hashBlockSize(int32_t);
void* hashCopy(int32_t, void*);
void hashFree(int32_t, void*);
void* hashNew(int32_t);
void hashReset(int32_t, void*);
int hashSize(int32_t);
void hashSum(int32_t, void*, uint8_t*);
void hashWrite(int32_t, void*, const uint8_t*, int);
void* initHMAC(int32_t, const uint8_t*, int);
int newPrivateKeyEd25519FromSeed(uint8_t*, const uint8_t*);
int newPublicKeyEd25519(uint8_t*, const uint8_t*);
int signEd25519(const uint8_t*, const uint8_t*, size_t, uint8_t*);
void updateHMAC(int32_t, void*, const uint8_t*, int);
int verifyEd25519(const uint8_t*, const uint8_t*, size_t, const uint8_t*);

void _mkcgo_MD5(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2) {
	MD5(_arg0, _arg1, _arg2);
}

void _mkcgo_SHA1(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2) {
	SHA1(_arg0, _arg1, _arg2);
}

void _mkcgo_SHA256(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2) {
	SHA256(_arg0, _arg1, _arg2);
}

void _mkcgo_SHA384(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2) {
	SHA384(_arg0, _arg1, _arg2);
}

void _mkcgo_SHA512(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2) {
	SHA512(_arg0, _arg1, _arg2);
}

void* _mkcgo_copyHMAC(int32_t _arg0, void* _arg1) {
	return copyHMAC(_arg0, _arg1);
}

int _mkcgo_decryptAESGCM(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2, size_t _arg3, const uint8_t* _arg4, size_t _arg5, const uint8_t* _arg6, size_t _arg7, const uint8_t* _arg8, size_t _arg9, uint8_t* _arg10, size_t* _arg11) {
	return decryptAESGCM(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, _arg11);
}

int _mkcgo_encryptAESGCM(const uint8_t* _arg0, size_t _arg1, const uint8_t* _arg2, size_t _arg3, const uint8_t* _arg4, size_t _arg5, const uint8_t* _arg6, size_t _arg7, uint8_t* _arg8, size_t _arg9, uint8_t* _arg10) {
	return encryptAESGCM(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10);
}

int _mkcgo_expandHKDF(int32_t _arg0, const uint8_t* _arg1, size_t _arg2, const uint8_t* _arg3, size_t _arg4, uint8_t* _arg5, size_t _arg6) {
	return expandHKDF(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6);
}

int _mkcgo_extractHKDF(int32_t _arg0, const uint8_t* _arg1, size_t _arg2, const uint8_t* _arg3, size_t _arg4, uint8_t* _arg5, size_t _arg6) {
	return extractHKDF(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6);
}

void _mkcgo_finalizeHMAC(int32_t _arg0, void* _arg1, uint8_t* _arg2) {
	finalizeHMAC(_arg0, _arg1, _arg2);
}

void _mkcgo_freeHMAC(int32_t _arg0, void* _arg1) {
	freeHMAC(_arg0, _arg1);
}

void _mkcgo_generateKeyEd25519(uint8_t* _arg0) {
	generateKeyEd25519(_arg0);
}

int _mkcgo_hashBlockSize(int32_t _arg0) {
	return hashBlockSize(_arg0);
}

void* _mkcgo_hashCopy(int32_t _arg0, void* _arg1) {
	return hashCopy(_arg0, _arg1);
}

void _mkcgo_hashFree(int32_t _arg0, void* _arg1) {
	hashFree(_arg0, _arg1);
}

void* _mkcgo_hashNew(int32_t _arg0) {
	return hashNew(_arg0);
}

void _mkcgo_hashReset(int32_t _arg0, void* _arg1) {
	hashReset(_arg0, _arg1);
}

int _mkcgo_hashSize(int32_t _arg0) {
	return hashSize(_arg0);
}

void _mkcgo_hashSum(int32_t _arg0, void* _arg1, uint8_t* _arg2) {
	hashSum(_arg0, _arg1, _arg2);
}

void _mkcgo_hashWrite(int32_t _arg0, void* _arg1, const uint8_t* _arg2, int _arg3) {
	hashWrite(_arg0, _arg1, _arg2, _arg3);
}

void* _mkcgo_initHMAC(int32_t _arg0, const uint8_t* _arg1, int _arg2) {
	return initHMAC(_arg0, _arg1, _arg2);
}

int _mkcgo_newPrivateKeyEd25519FromSeed(uint8_t* _arg0, const uint8_t* _arg1) {
	return newPrivateKeyEd25519FromSeed(_arg0, _arg1);
}

int _mkcgo_newPublicKeyEd25519(uint8_t* _arg0, const uint8_t* _arg1) {
	return newPublicKeyEd25519(_arg0, _arg1);
}

int _mkcgo_signEd25519(const uint8_t* _arg0, const uint8_t* _arg1, size_t _arg2, uint8_t* _arg3) {
	return signEd25519(_arg0, _arg1, _arg2, _arg3);
}

void _mkcgo_updateHMAC(int32_t _arg0, void* _arg1, const uint8_t* _arg2, int _arg3) {
	updateHMAC(_arg0, _arg1, _arg2, _arg3);
}

int _mkcgo_verifyEd25519(const uint8_t* _arg0, const uint8_t* _arg1, size_t _arg2, const uint8_t* _arg3) {
	return verifyEd25519(_arg0, _arg1, _arg2, _arg3);
}

