// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

package main

import (
	"bytes"
	"cmp"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/microsoft/go-crypto-darwin/internal/mkcgo"
)

var (
	fileName          = flag.String("out", "", "output file name (standard output if omitted)")
	includeHeader     = flag.String("include", "", "include header file")
	packageName       = flag.String("package", "", "package name")
	private           = flag.Bool("private", false, "all Go generated symbols are kept unexported")
	useDynamicLoading = flag.Bool("dynamic-loading", true, "use dynamic loading")
	errors            = flag.Bool("errors", false, "enable error handling")
)

func usage() {
	fmt.Fprintf(os.Stderr, "usage: mkcgo [flags] [path ...]\n")
	flag.PrintDefaults()
	fmt.Fprintf(os.Stderr, "\n")
	os.Exit(1)
}

func main() {
	// Set up and parse flags.
	flag.Usage = usage
	flag.Parse()
	if len(flag.Args()) == 0 {
		fmt.Fprintln(os.Stderr, "no files to parse provided")
		usage()
	}

	var src mkcgo.Source
	// Parse source files.
	for _, arg := range flag.Args() {
		file, err := os.Open(arg)
		if err != nil {
			log.Fatal(err)
		}
		err = src.Parse(file)
		file.Close()
		if err != nil {
			log.Fatal(err)
		}
	}

	// Sort functions by name to get deterministic output
	// even when the order of the functions in the source file changes.
	slices.SortFunc(src.Funcs, func(a, b *mkcgo.Func) int {
		return cmp.Compare(a.Name, b.Name)
	})

	var gobuf, go124buf, hbuf, cbuf bytes.Buffer
	generateGo(&src, &gobuf)
	generateGo124(&src, &go124buf)
	generateCHeader(&src, &hbuf)
	generateC(&src, &cbuf)

	// Format the generated Go source code.
	godata := goformat(gobuf.Bytes())
	go124data := goformat(go124buf.Bytes())

	for _, d := range []struct {
		suffix string
		data   []byte
	}{
		{".go", godata},
		{"_go124.go", go124data},
		{".h", hbuf.Bytes()},
		{".c", cbuf.Bytes()},
	} {
		name := autogeneratedFileName(d.suffix)
		var err error
		if *fileName == "" {
			// Write output. If no explicit output file is specified,
			// // write both Go and C output to stdout.
			os.Stdout.WriteString("// === " + name + " ===\n\n")
			_, err = os.Stdout.Write(d.data)
		} else {
			err = os.WriteFile(name, d.data, 0o644)
		}
		if err != nil {
			log.Fatal(err)
		}
	}
}

// autogeneratedFileName returns the name of the autogenerated file
// using the provided suffix.
func autogeneratedFileName(suffix string) string {
	var baseName string
	if *fileName == "" {
		baseName = "mkcgo"
	} else {
		baseName = strings.TrimSuffix(*fileName, ".go")
	}
	return baseName + suffix
}

func writeTempSourceFile(data []byte) (string, error) {
	f, err := os.CreateTemp("", "mkcgo-generated-*.go")
	if err != nil {
		return "", err
	}
	_, err = f.Write(data)
	if closeErr := f.Close(); err == nil {
		err = closeErr
	}
	if err != nil {
		os.Remove(f.Name()) // best effort
		return "", err
	}
	return f.Name(), nil
}

func goformat(data []byte) []byte {
	data, err := format.Source(data)
	if err != nil {
		log.Printf("failed to format source: %v", err)
		f, err := writeTempSourceFile(data)
		if err != nil {
			log.Fatalf("failed to write unformatted source to file: %v", err)
		}
		log.Fatalf("for diagnosis, wrote unformatted source to %v", f)
	}
	return data
}
